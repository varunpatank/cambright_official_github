<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Startup Checker Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a1a;
            color: white;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 8px;
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .error {
            background-color: #f44336;
        }
        .warning {
            background-color: #ff9800;
        }
        #log {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Startup Checker Implementation Test</h1>
    
    <div class="test-section">
        <h2>Test Scenarios</h2>
        <p>This page tests the improved startup-checker functionality:</p>
        <ul>
            <li><strong>Retry Logic:</strong> Exponential backoff with jitter</li>
            <li><strong>Error Differentiation:</strong> Network vs Server vs Timeout errors</li>
            <li><strong>Timeout Handling:</strong> 60-second total timeout</li>
            <li><strong>Progress Indication:</strong> Better loading states</li>
        </ul>
    </div>

    <div class="test-section">
        <h2>Manual Tests</h2>
        <button onclick="testNetworkError()">Test Network Error</button>
        <button onclick="testServerError()">Test Server Error (503)</button>
        <button onclick="testTimeout()">Test Timeout</button>
        <button onclick="testRetryLogic()">Test Retry Logic</button>
        <button onclick="testHealthyResponse()">Test Healthy Response</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div class="test-section">
        <h2>Test Log</h2>
        <div id="log"></div>
    </div>

    <script>
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#ff6b6b' : type === 'warning' ? '#ffa726' : '#4ecdc4';
            logDiv.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        // Simulate the retry logic from the component
        async function simulateStartupChecker(mockFetch) {
            const STARTUP_TIMEOUT = 60000;
            const BASE_DELAY = 1000;
            const MAX_DELAY = 10000;
            const BACKOFF_MULTIPLIER = 1.5;
            const MAX_ATTEMPTS = 5;

            let retryState = {
                attempt: 0,
                maxAttempts: MAX_ATTEMPTS,
                delay: BASE_DELAY,
                startTime: Date.now()
            };

            const determineErrorType = (error, response) => {
                if (!response && (
                    error.message.includes('fetch') ||
                    error.message.includes('network') ||
                    error.message.includes('Failed to fetch') ||
                    error.name === 'TypeError'
                )) {
                    return 'network';
                }
                if (error.message.includes('timeout') || error.name === 'AbortError') {
                    return 'timeout';
                }
                if (response && response.status >= 500) {
                    return 'server';
                }
                return 'unknown';
            };

            const calculateNextDelay = (attempt, baseDelay) => {
                const exponentialDelay = baseDelay * Math.pow(BACKOFF_MULTIPLIER, attempt);
                const jitteredDelay = exponentialDelay * (0.5 + Math.random() * 0.5);
                return Math.min(jitteredDelay, MAX_DELAY);
            };

            const shouldRetry = (errorType, attempt, startTime) => {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime >= STARTUP_TIMEOUT) return false;
                if (attempt >= MAX_ATTEMPTS) return false;
                return errorType === 'network' || errorType === 'timeout' || errorType === 'server';
            };

            const runChecks = async (currentRetryState = retryState) => {
                try {
                    const attemptLog = currentRetryState.attempt > 0 
                        ? ` (attempt ${currentRetryState.attempt + 1}/${currentRetryState.maxAttempts})`
                        : '';
                    log(`ðŸ” Fetching server startup status${attemptLog}...`);

                    const response = await mockFetch();
                    
                    if (response.status === 503) {
                        const report = await response.json().catch(() => ({ status: 'initializing' }));
                        if (report.status === 'initializing') {
                            log('â³ Server is still initializing, retrying...', 'warning');
                            const nextDelay = calculateNextDelay(currentRetryState.attempt, BASE_DELAY);
                            const nextRetryState = {
                                ...currentRetryState,
                                attempt: currentRetryState.attempt + 1,
                                delay: nextDelay,
                                errorType: 'server'
                            };
                            
                            if (shouldRetry('server', nextRetryState.attempt, currentRetryState.startTime)) {
                                log(`ðŸ”„ Retrying in ${Math.round(nextDelay / 1000)}s...`);
                                setTimeout(() => runChecks(nextRetryState), nextDelay);
                                return;
                            }
                        }
                    }

                    if (!response.ok) {
                        throw new Error(`Health check failed: ${response.status} ${response.statusText}`);
                    }

                    const report = await response.json();
                    log(`ðŸ“Š Server startup report received: ${report.overall}`, 'info');
                    log('âœ… Health checks completed successfully!', 'info');
                    
                } catch (error) {
                    const errorType = determineErrorType(error, undefined);
                    const nextRetryState = {
                        ...currentRetryState,
                        attempt: currentRetryState.attempt + 1,
                        delay: calculateNextDelay(currentRetryState.attempt, currentRetryState.delay),
                        lastError: error,
                        errorType
                    };

                    log(`ðŸ’¥ Startup check failed (${errorType} error): ${error.message}`, 'error');

                    if (shouldRetry(errorType, nextRetryState.attempt, currentRetryState.startTime)) {
                        log(`ðŸ”„ Retrying in ${Math.round(nextRetryState.delay / 1000)}s... (${errorType} error)`, 'warning');
                        setTimeout(() => runChecks(nextRetryState), nextRetryState.delay);
                    } else {
                        log('âŒ Max retries exceeded or timeout reached, giving up', 'error');
                    }
                }
            };

            await runChecks();
        }

        function testNetworkError() {
            log('=== Testing Network Error ===');
            const mockFetch = () => Promise.reject(new Error('Failed to fetch'));
            simulateStartupChecker(mockFetch);
        }

        function testServerError() {
            log('=== Testing Server Error (503) ===');
            let callCount = 0;
            const mockFetch = () => {
                callCount++;
                if (callCount <= 2) {
                    return Promise.resolve({
                        ok: false,
                        status: 503,
                        json: () => Promise.resolve({ status: 'initializing' })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    json: () => Promise.resolve({
                        overall: 'healthy',
                        checks: [],
                        totalTime: 1000,
                        criticalFailures: 0,
                        warnings: 0
                    })
                });
            };
            simulateStartupChecker(mockFetch);
        }

        function testTimeout() {
            log('=== Testing Timeout ===');
            const mockFetch = () => {
                return new Promise((_, reject) => {
                    setTimeout(() => {
                        const error = new Error('The operation was aborted');
                        error.name = 'AbortError';
                        reject(error);
                    }, 1000);
                });
            };
            simulateStartupChecker(mockFetch);
        }

        function testRetryLogic() {
            log('=== Testing Retry Logic ===');
            let callCount = 0;
            const mockFetch = () => {
                callCount++;
                if (callCount <= 3) {
                    return Promise.reject(new Error('Failed to fetch'));
                }
                return Promise.resolve({
                    ok: true,
                    json: () => Promise.resolve({
                        overall: 'healthy',
                        checks: [],
                        totalTime: 1000,
                        criticalFailures: 0,
                        warnings: 0
                    })
                });
            };
            simulateStartupChecker(mockFetch);
        }

        function testHealthyResponse() {
            log('=== Testing Healthy Response ===');
            const mockFetch = () => Promise.resolve({
                ok: true,
                json: () => Promise.resolve({
                    overall: 'healthy',
                    checks: [
                        {
                            service: 'Database',
                            status: 'healthy',
                            message: 'Connected successfully',
                            timestamp: new Date().toISOString()
                        }
                    ],
                    totalTime: 500,
                    criticalFailures: 0,
                    warnings: 0
                })
            });
            simulateStartupChecker(mockFetch);
        }

        log('Startup Checker Test Page Loaded');
        log('Click the buttons above to test different scenarios');
    </script>
</body>
</html>